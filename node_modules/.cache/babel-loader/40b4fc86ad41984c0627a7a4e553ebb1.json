{"ast":null,"code":"import _defineProperty from \"E:/GoIT/Zad dom/goit-react-hw-08-phonebook/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _assertThisInitialized from \"E:/GoIT/Zad dom/goit-react-hw-08-phonebook/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"E:/GoIT/Zad dom/goit-react-hw-08-phonebook/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/GoIT/Zad dom/goit-react-hw-08-phonebook/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"E:/GoIT/Zad dom/goit-react-hw-08-phonebook/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _classCallCheck from \"E:/GoIT/Zad dom/goit-react-hw-08-phonebook/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/GoIT/Zad dom/goit-react-hw-08-phonebook/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _objectSpread from \"E:/GoIT/Zad dom/goit-react-hw-08-phonebook/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"E:/GoIT/Zad dom/goit-react-hw-08-phonebook/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\");\n\n// src/utils/errors.ts\nvar errors = process.env.NODE_ENV !== \"production\" ? [\n// All error codes, starting by 0:\nfunction (plugin) {\n  return \"The plugin for '\".concat(plugin, \"' has not been loaded into Immer. To enable the plugin, import and call `enable\").concat(plugin, \"()` when initializing your application.\");\n}, function (thing) {\n  return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\".concat(thing, \"'\");\n}, \"This object has been frozen and should not be mutated\", function (data) {\n  return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n}, \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\", \"Immer forbids circular references\", \"The first or second argument to `produce` must be a function\", \"The third argument to `produce` must be a function or undefined\", \"First argument to `createDraft` must be a plain object, an array, or an immerable object\", \"First argument to `finishDraft` must be a draft returned by `createDraft`\", function (thing) {\n  return \"'current' expects a draft, got: \".concat(thing);\n}, \"Object.defineProperty() cannot be used on an Immer draft\", \"Object.setPrototypeOf() cannot be used on an Immer draft\", \"Immer only supports deleting array indices\", \"Immer only supports setting array indices and the 'length' property\", function (thing) {\n  return \"'original' expects a draft, got: \".concat(thing);\n}\n// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n// See Patches.ts for additional errors\n] : [];\nfunction die(error) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var e = errors[error];\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    var msg = typeof e === \"function\" ? e.apply(null, args) : e;\n    throw new Error(\"[Immer] \".concat(msg));\n  }\n  throw new Error(\"[Immer] minified error nr: \".concat(error, \". Full error at: https://bit.ly/3cXEKWf\"));\n}\n\n// src/utils/common.ts\nvar _getPrototypeOf = Object.getPrototypeOf;\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  var _value$constructor;\n  if (!value) return false;\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);\n}\nvar objectCtorString = Object.prototype.constructor.toString();\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") return false;\n  var proto = _getPrototypeOf(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  if (Ctor === Object) return true;\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n  if (!isDraft(value)) die(15, value);\n  return value[DRAFT_STATE].base_;\n}\nfunction each(obj, iter) {\n  if (getArchtype(obj) === 0 /* Object */) {\n    Object.entries(obj).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n      iter(key, value, obj);\n    });\n  } else {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  }\n}\nfunction getArchtype(thing) {\n  var state = thing[DRAFT_STATE];\n  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;\n}\n\nfunction has(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.get(prop) : thing[prop];\n}\nfunction set(thing, propOrOldValue, value) {\n  var t = getArchtype(thing);\n  if (t === 2 /* Map */) thing.set(propOrOldValue, value);else if (t === 3 /* Set */) {\n    thing.add(value);\n  } else thing[propOrOldValue] = value;\n}\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction isMap(target) {\n  return target instanceof Map;\n}\nfunction isSet(target) {\n  return target instanceof Set;\n}\nfunction latest(state) {\n  return state.copy_ || state.base_;\n}\nfunction shallowCopy(base, strict) {\n  if (isMap(base)) {\n    return new Map(base);\n  }\n  if (isSet(base)) {\n    return new Set(base);\n  }\n  if (Array.isArray(base)) return Array.prototype.slice.call(base);\n  if (!strict && isPlainObject(base)) {\n    if (!_getPrototypeOf(base)) {\n      var obj = /* @__PURE__ */Object.create(null);\n      return Object.assign(obj, base);\n    }\n    return _objectSpread({}, base);\n  }\n  var descriptors = Object.getOwnPropertyDescriptors(base);\n  delete descriptors[DRAFT_STATE];\n  var keys = Reflect.ownKeys(descriptors);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var desc = descriptors[key];\n    if (desc.writable === false) {\n      desc.writable = true;\n      desc.configurable = true;\n    }\n    if (desc.get || desc.set) descriptors[key] = {\n      configurable: true,\n      writable: true,\n      // could live with !!desc.set as well here...\n      enumerable: desc.enumerable,\n      value: base[key]\n    };\n  }\n  return Object.create(_getPrototypeOf(base), descriptors);\n}\nfunction freeze(obj) {\n  var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n  if (getArchtype(obj) > 1) {\n    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n  Object.freeze(obj);\n  if (deep) each(obj, function (_key, value) {\n    return freeze(value, true);\n  }, true);\n  return obj;\n}\nfunction dontMutateFrozenCollections() {\n  die(2);\n}\nfunction isFrozen(obj) {\n  return Object.isFrozen(obj);\n}\n\n// src/utils/plugins.ts\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n  var plugin = plugins[pluginKey];\n  if (!plugin) {\n    die(0, pluginKey);\n  }\n  return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n}\n\n// src/core/scope.ts\nvar currentScope;\nfunction getCurrentScope() {\n  return currentScope;\n}\nfunction createScope(parent_, immer_) {\n  return {\n    drafts_: [],\n    parent_: parent_,\n    immer_: immer_,\n    // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n    canAutoFreeze_: true,\n    unfinalizedDrafts_: 0\n  };\n}\nfunction usePatchesInScope(scope, patchListener) {\n  if (patchListener) {\n    getPlugin(\"Patches\");\n    scope.patches_ = [];\n    scope.inversePatches_ = [];\n    scope.patchListener_ = patchListener;\n  }\n}\nfunction revokeScope(scope) {\n  leaveScope(scope);\n  scope.drafts_.forEach(revokeDraft);\n  scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n  if (scope === currentScope) {\n    currentScope = scope.parent_;\n  }\n}\nfunction enterScope(immer2) {\n  return currentScope = createScope(currentScope, immer2);\n}\nfunction revokeDraft(draft) {\n  var state = draft[DRAFT_STATE];\n  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */) state.revoke_();else state.revoked_ = true;\n}\n\n// src/core/finalize.ts\nfunction processResult(result, scope) {\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\n  var baseDraft = scope.drafts_[0];\n  var isReplaced = result !== void 0 && result !== baseDraft;\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified_) {\n      revokeScope(scope);\n      die(4);\n    }\n    if (isDraftable(result)) {\n      result = finalize(scope, result);\n      if (!scope.parent_) maybeFreeze(scope, result);\n    }\n    if (scope.patches_) {\n      getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);\n    }\n  } else {\n    result = finalize(scope, baseDraft, []);\n  }\n  revokeScope(scope);\n  if (scope.patches_) {\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\n  }\n  return result !== NOTHING ? result : void 0;\n}\nfunction finalize(rootScope, value, path) {\n  if (isFrozen(value)) return value;\n  var state = value[DRAFT_STATE];\n  if (!state) {\n    each(value, function (key, childValue) {\n      return finalizeProperty(rootScope, state, value, key, childValue, path);\n    }, true\n    // See #590, don't recurse into non-enumerable of non drafted objects\n    );\n\n    return value;\n  }\n  if (state.scope_ !== rootScope) return value;\n  if (!state.modified_) {\n    maybeFreeze(rootScope, state.base_, true);\n    return state.base_;\n  }\n  if (!state.finalized_) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n    var result = state.copy_;\n    var resultEach = result;\n    var isSet2 = false;\n    if (state.type_ === 3 /* Set */) {\n      resultEach = new Set(result);\n      result.clear();\n      isSet2 = true;\n    }\n    each(resultEach, function (key, childValue) {\n      return finalizeProperty(rootScope, state, result, key, childValue, path, isSet2);\n    });\n    maybeFreeze(rootScope, result, false);\n    if (path && rootScope.patches_) {\n      getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);\n    }\n  }\n  return state.copy_;\n}\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n  if (process.env.NODE_ENV !== \"production\" && childValue === targetObject) die(5);\n  if (isDraft(childValue)) {\n    var path = rootPath && parentState && parentState.type_ !== 3 /* Set */ &&\n    // Set objects are atomic since they have no keys.\n    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;\n    var res = finalize(rootScope, childValue, path);\n    set(targetObject, prop, res);\n    if (isDraft(res)) {\n      rootScope.canAutoFreeze_ = false;\n    } else return;\n  } else if (targetIsSet) {\n    targetObject.add(childValue);\n  }\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n      return;\n    }\n    finalize(rootScope, childValue);\n    if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);\n  }\n}\nfunction maybeFreeze(scope, value) {\n  var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n    freeze(value, deep);\n  }\n}\n\n// src/core/proxy.ts\nfunction createProxyProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var state = {\n    type_: isArray ? 1 /* Array */ : 0 /* Object */,\n\n    // Track which produce call this is associated with.\n    scope_: parent ? parent.scope_ : getCurrentScope(),\n    // True for both shallow and deep changes.\n    modified_: false,\n    // Used during finalization.\n    finalized_: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned_: {},\n    // The parent draft state.\n    parent_: parent,\n    // The base state.\n    base_: base,\n    // The base proxy.\n    draft_: null,\n    // set below\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: false\n  };\n  var target = state;\n  var traps = objectTraps;\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  }\n  var _Proxy$revocable = Proxy.revocable(target, traps),\n    revoke = _Proxy$revocable.revoke,\n    proxy = _Proxy$revocable.proxy;\n  state.draft_ = proxy;\n  state.revoke_ = revoke;\n  return proxy;\n}\nvar objectTraps = {\n  get: function get(state, prop) {\n    if (prop === DRAFT_STATE) return state;\n    var source = latest(state);\n    if (!has(source, prop)) {\n      return readPropFromProto(state, source, prop);\n    }\n    var value = source[prop];\n    if (state.finalized_ || !isDraftable(value)) {\n      return value;\n    }\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      return state.copy_[prop] = createProxy(value, state);\n    }\n    return value;\n  },\n  has: function has(state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys: function ownKeys(state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set: function set(state, prop, value) {\n    var desc = getDescriptorFromProto(latest(state), prop);\n    if (desc !== null && desc !== void 0 && desc.set) {\n      desc.set.call(state.draft_, value);\n      return true;\n    }\n    if (!state.modified_) {\n      var current2 = peek(latest(state), prop);\n      var currentState = current2 === null || current2 === void 0 ? void 0 : current2[DRAFT_STATE];\n      if (currentState && currentState.base_ === value) {\n        state.copy_[prop] = value;\n        state.assigned_[prop] = false;\n        return true;\n      }\n      if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;\n      prepareCopy(state);\n      markChanged(state);\n    }\n    if (state.copy_[prop] === value && (\n    // special case: handle new props with value 'undefined'\n    value !== void 0 || prop in state.copy_) ||\n    // special case: NaN\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;\n    state.copy_[prop] = value;\n    state.assigned_[prop] = true;\n    return true;\n  },\n  deleteProperty: function deleteProperty(state, prop) {\n    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n      state.assigned_[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else {\n      delete state.assigned_[prop];\n    }\n    if (state.copy_) {\n      delete state.copy_[prop];\n    }\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n    var owner = latest(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (!desc) return desc;\n    return {\n      writable: true,\n      configurable: state.type_ !== 1 /* Array */ || prop !== \"length\",\n      enumerable: desc.enumerable,\n      value: owner[prop]\n    };\n  },\n  defineProperty: function defineProperty() {\n    die(11);\n  },\n  getPrototypeOf: function getPrototypeOf(state) {\n    return _getPrototypeOf(state.base_);\n  },\n  setPrototypeOf: function setPrototypeOf() {\n    die(12);\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\narrayTraps.deleteProperty = function (state, prop) {\n  if (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop))) die(13);\n  return arrayTraps.set.call(this, state, prop, void 0);\n};\narrayTraps.set = function (state, prop, value) {\n  if (process.env.NODE_ENV !== \"production\" && prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var source = state ? latest(state) : draft;\n  return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n  var _desc$get;\n  var desc = getDescriptorFromProto(source, prop);\n  return desc ? \"value\" in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the\n  // prototype, we should invoke it with the draft as context!\n  (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : void 0;\n}\nfunction getDescriptorFromProto(source, prop) {\n  if (!(prop in source)) return void 0;\n  var proto = _getPrototypeOf(source);\n  while (proto) {\n    var desc = Object.getOwnPropertyDescriptor(proto, prop);\n    if (desc) return desc;\n    proto = _getPrototypeOf(proto);\n  }\n  return void 0;\n}\nfunction markChanged(state) {\n  if (!state.modified_) {\n    state.modified_ = true;\n    if (state.parent_) {\n      markChanged(state.parent_);\n    }\n  }\n}\nfunction prepareCopy(state) {\n  if (!state.copy_) {\n    state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);\n  }\n}\n\n// src/core/immerClass.ts\nvar Immer2 = /*#__PURE__*/function () {\n  function Immer2(config) {\n    var _this = this;\n    _classCallCheck(this, Immer2);\n    this.autoFreeze_ = true;\n    this.useStrictShallowCopy_ = false;\n    /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */\n    this.produce = function (base, recipe, patchListener) {\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\n        var defaultBase = recipe;\n        recipe = base;\n        var self = _this;\n        return function curriedProduce() {\n          var _this2 = this;\n          var base2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultBase;\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {\n            args[_key3 - 1] = arguments[_key3];\n          }\n          return self.produce(base2, function (draft) {\n            var _recipe;\n            return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));\n          });\n        };\n      }\n      if (typeof recipe !== \"function\") die(6);\n      if (patchListener !== void 0 && typeof patchListener !== \"function\") die(7);\n      var result;\n      if (isDraftable(base)) {\n        var scope = enterScope(_this);\n        var proxy = createProxy(base, void 0);\n        var hasError = true;\n        try {\n          result = recipe(proxy);\n          hasError = false;\n        } finally {\n          if (hasError) revokeScope(scope);else leaveScope(scope);\n        }\n        usePatchesInScope(scope, patchListener);\n        return processResult(result, scope);\n      } else if (!base || typeof base !== \"object\") {\n        result = recipe(base);\n        if (result === void 0) result = base;\n        if (result === NOTHING) result = void 0;\n        if (_this.autoFreeze_) freeze(result, true);\n        if (patchListener) {\n          var p = [];\n          var ip = [];\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n          patchListener(p, ip);\n        }\n        return result;\n      } else die(1, base);\n    };\n    this.produceWithPatches = function (base, recipe) {\n      if (typeof base === \"function\") {\n        return function (state) {\n          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {\n            args[_key4 - 1] = arguments[_key4];\n          }\n          return _this.produceWithPatches(state, function (draft) {\n            return base.apply(void 0, [draft].concat(args));\n          });\n        };\n      }\n      var patches, inversePatches;\n      var result = _this.produce(base, recipe, function (p, ip) {\n        patches = p;\n        inversePatches = ip;\n      });\n      return [result, patches, inversePatches];\n    };\n    if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === \"boolean\") this.setAutoFreeze(config.autoFreeze);\n    if (typeof (config === null || config === void 0 ? void 0 : config.useStrictShallowCopy) === \"boolean\") this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n  }\n  _createClass(Immer2, [{\n    key: \"createDraft\",\n    value: function createDraft(base) {\n      if (!isDraftable(base)) die(8);\n      if (isDraft(base)) base = current(base);\n      var scope = enterScope(this);\n      var proxy = createProxy(base, void 0);\n      proxy[DRAFT_STATE].isManual_ = true;\n      leaveScope(scope);\n      return proxy;\n    }\n  }, {\n    key: \"finishDraft\",\n    value: function finishDraft(draft, patchListener) {\n      var state = draft && draft[DRAFT_STATE];\n      if (!state || !state.isManual_) die(9);\n      var scope = state.scope_;\n      usePatchesInScope(scope, patchListener);\n      return processResult(void 0, scope);\n    }\n    /**\n     * Pass true to automatically freeze all copies created by Immer.\n     *\n     * By default, auto-freezing is enabled.\n     */\n  }, {\n    key: \"setAutoFreeze\",\n    value: function setAutoFreeze(value) {\n      this.autoFreeze_ = value;\n    }\n    /**\n     * Pass true to enable strict shallow copy.\n     *\n     * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n     */\n  }, {\n    key: \"setUseStrictShallowCopy\",\n    value: function setUseStrictShallowCopy(value) {\n      this.useStrictShallowCopy_ = value;\n    }\n  }, {\n    key: \"applyPatches\",\n    value: function applyPatches(base, patches) {\n      var i;\n      for (i = patches.length - 1; i >= 0; i--) {\n        var patch = patches[i];\n        if (patch.path.length === 0 && patch.op === \"replace\") {\n          base = patch.value;\n          break;\n        }\n      }\n      if (i > -1) {\n        patches = patches.slice(i + 1);\n      }\n      var applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n      if (isDraft(base)) {\n        return applyPatchesImpl(base, patches);\n      }\n      return this.produce(base, function (draft) {\n        return applyPatchesImpl(draft, patches);\n      });\n    }\n  }]);\n  return Immer2;\n}();\nfunction createProxy(value, parent) {\n  var draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : createProxyProxy(value, parent);\n  var scope = parent ? parent.scope_ : getCurrentScope();\n  scope.drafts_.push(draft);\n  return draft;\n}\n\n// src/core/current.ts\nfunction current(value) {\n  if (!isDraft(value)) die(10, value);\n  return currentImpl(value);\n}\nfunction currentImpl(value) {\n  if (!isDraftable(value) || isFrozen(value)) return value;\n  var state = value[DRAFT_STATE];\n  var copy;\n  if (state) {\n    if (!state.modified_) return state.base_;\n    state.finalized_ = true;\n    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n  } else {\n    copy = shallowCopy(value, true);\n  }\n  each(copy, function (key, childValue) {\n    set(copy, key, currentImpl(childValue));\n  });\n  if (state) {\n    state.finalized_ = false;\n  }\n  return copy;\n}\n\n// src/plugins/patches.ts\nfunction enablePatches() {\n  var errorOffset = 16;\n  if (process.env.NODE_ENV !== \"production\") {\n    errors.push('Sets cannot have \"replace\" patches.', function (op) {\n      return \"Unsupported patch operation: \" + op;\n    }, function (path) {\n      return \"Cannot apply patch, path doesn't resolve: \" + path;\n    }, \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\");\n  }\n  var REPLACE = \"replace\";\n  var ADD = \"add\";\n  var REMOVE = \"remove\";\n  function generatePatches_(state, basePath, patches, inversePatches) {\n    switch (state.type_) {\n      case 0 /* Object */:\n      case 2 /* Map */:\n        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n      case 1 /* Array */:\n        return generateArrayPatches(state, basePath, patches, inversePatches);\n      case 3 /* Set */:\n        return generateSetPatches(state, basePath, patches, inversePatches);\n    }\n  }\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\n    var base_ = state.base_,\n      assigned_ = state.assigned_;\n    var copy_ = state.copy_;\n    if (copy_.length < base_.length) {\n      ;\n      var _ref3 = [copy_, base_];\n      base_ = _ref3[0];\n      copy_ = _ref3[1];\n      var _ref4 = [inversePatches, patches];\n      patches = _ref4[0];\n      inversePatches = _ref4[1];\n    }\n    for (var i = 0; i < base_.length; i++) {\n      if (assigned_[i] && copy_[i] !== base_[i]) {\n        var path = basePath.concat([i]);\n        patches.push({\n          op: REPLACE,\n          path: path,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: clonePatchValueIfNeeded(copy_[i])\n        });\n        inversePatches.push({\n          op: REPLACE,\n          path: path,\n          value: clonePatchValueIfNeeded(base_[i])\n        });\n      }\n    }\n    for (var _i = base_.length; _i < copy_.length; _i++) {\n      var _path = basePath.concat([_i]);\n      patches.push({\n        op: ADD,\n        path: _path,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: clonePatchValueIfNeeded(copy_[_i])\n      });\n    }\n    for (var _i2 = copy_.length - 1; base_.length <= _i2; --_i2) {\n      var _path2 = basePath.concat([_i2]);\n      inversePatches.push({\n        op: REMOVE,\n        path: _path2\n      });\n    }\n  }\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n    var base_ = state.base_,\n      copy_ = state.copy_;\n    each(state.assigned_, function (key, assignedValue) {\n      var origValue = get(base_, key);\n      var value = get(copy_, key);\n      var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n      if (origValue === value && op === REPLACE) return;\n      var path = basePath.concat(key);\n      patches.push(op === REMOVE ? {\n        op: op,\n        path: path\n      } : {\n        op: op,\n        path: path,\n        value: value\n      });\n      inversePatches.push(op === ADD ? {\n        op: REMOVE,\n        path: path\n      } : op === REMOVE ? {\n        op: ADD,\n        path: path,\n        value: clonePatchValueIfNeeded(origValue)\n      } : {\n        op: REPLACE,\n        path: path,\n        value: clonePatchValueIfNeeded(origValue)\n      });\n    });\n  }\n  function generateSetPatches(state, basePath, patches, inversePatches) {\n    var base_ = state.base_,\n      copy_ = state.copy_;\n    var i = 0;\n    base_.forEach(function (value) {\n      if (!copy_.has(value)) {\n        var path = basePath.concat([i]);\n        patches.push({\n          op: REMOVE,\n          path: path,\n          value: value\n        });\n        inversePatches.unshift({\n          op: ADD,\n          path: path,\n          value: value\n        });\n      }\n      i++;\n    });\n    i = 0;\n    copy_.forEach(function (value) {\n      if (!base_.has(value)) {\n        var path = basePath.concat([i]);\n        patches.push({\n          op: ADD,\n          path: path,\n          value: value\n        });\n        inversePatches.unshift({\n          op: REMOVE,\n          path: path,\n          value: value\n        });\n      }\n      i++;\n    });\n  }\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n    patches.push({\n      op: REPLACE,\n      path: [],\n      value: replacement === NOTHING ? void 0 : replacement\n    });\n    inversePatches.push({\n      op: REPLACE,\n      path: [],\n      value: baseValue\n    });\n  }\n  function applyPatches_(draft, patches) {\n    patches.forEach(function (patch) {\n      var path = patch.path,\n        op = patch.op;\n      var base = draft;\n      for (var i = 0; i < path.length - 1; i++) {\n        var parentType = getArchtype(base);\n        var p = path[i];\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\n          p = \"\" + p;\n        }\n        if ((parentType === 0 /* Object */ || parentType === 1 /* Array */) && (p === \"__proto__\" || p === \"constructor\")) die(errorOffset + 3);\n        if (typeof base === \"function\" && p === \"prototype\") die(errorOffset + 3);\n        base = get(base, p);\n        if (typeof base !== \"object\") die(errorOffset + 2, path.join(\"/\"));\n      }\n      var type = getArchtype(base);\n      var value = deepClonePatchValue(patch.value);\n      var key = path[path.length - 1];\n      switch (op) {\n        case REPLACE:\n          switch (type) {\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              die(errorOffset);\n            default:\n              return base[key] = value;\n          }\n        case ADD:\n          switch (type) {\n            case 1 /* Array */:\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              return base.add(value);\n            default:\n              return base[key] = value;\n          }\n        case REMOVE:\n          switch (type) {\n            case 1 /* Array */:\n              return base.splice(key, 1);\n            case 2 /* Map */:\n              return base.delete(key);\n            case 3 /* Set */:\n              return base.delete(patch.value);\n            default:\n              return delete base[key];\n          }\n        default:\n          die(errorOffset + 1, op);\n      }\n    });\n    return draft;\n  }\n  function deepClonePatchValue(obj) {\n    if (!isDraftable(obj)) return obj;\n    if (Array.isArray(obj)) return obj.map(deepClonePatchValue);\n    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n        k = _ref6[0],\n        v = _ref6[1];\n      return [k, deepClonePatchValue(v)];\n    }));\n    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n    var cloned = Object.create(_getPrototypeOf(obj));\n    for (var key in obj) {\n      cloned[key] = deepClonePatchValue(obj[key]);\n    }\n    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n    return cloned;\n  }\n  function clonePatchValueIfNeeded(obj) {\n    if (isDraft(obj)) {\n      return deepClonePatchValue(obj);\n    } else return obj;\n  }\n  loadPlugin(\"Patches\", {\n    applyPatches_: applyPatches_,\n    generatePatches_: generatePatches_,\n    generateReplacementPatches_: generateReplacementPatches_\n  });\n}\n\n// src/plugins/mapset.ts\nfunction enableMapSet() {\n  var DraftMap = /*#__PURE__*/function (_Map, _ref7) {\n    _inherits(DraftMap, _Map);\n    var _super = _createSuper(DraftMap);\n    function DraftMap(target, parent) {\n      var _this3;\n      _classCallCheck(this, DraftMap);\n      _this3 = _super.call(this);\n      _this3[DRAFT_STATE] = {\n        type_: 2 /* Map */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        assigned_: void 0,\n        base_: target,\n        draft_: _assertThisInitialized(_this3),\n        isManual_: false,\n        revoked_: false\n      };\n      return _this3;\n    }\n    _createClass(DraftMap, [{\n      key: \"size\",\n      get: function get() {\n        return latest(this[DRAFT_STATE]).size;\n      }\n    }, {\n      key: \"has\",\n      value: function has(key) {\n        return latest(this[DRAFT_STATE]).has(key);\n      }\n    }, {\n      key: \"set\",\n      value: function set(key, value) {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        if (!latest(state).has(key) || latest(state).get(key) !== value) {\n          prepareMapCopy(state);\n          markChanged(state);\n          state.assigned_.set(key, true);\n          state.copy_.set(key, value);\n          state.assigned_.set(key, true);\n        }\n        return this;\n      }\n    }, {\n      key: \"delete\",\n      value: function _delete(key) {\n        if (!this.has(key)) {\n          return false;\n        }\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        prepareMapCopy(state);\n        markChanged(state);\n        if (state.base_.has(key)) {\n          state.assigned_.set(key, false);\n        } else {\n          state.assigned_.delete(key);\n        }\n        state.copy_.delete(key);\n        return true;\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        if (latest(state).size) {\n          prepareMapCopy(state);\n          markChanged(state);\n          state.assigned_ = /* @__PURE__ */new Map();\n          each(state.base_, function (key) {\n            state.assigned_.set(key, false);\n          });\n          state.copy_.clear();\n        }\n      }\n    }, {\n      key: \"forEach\",\n      value: function forEach(cb, thisArg) {\n        var _this4 = this;\n        var state = this[DRAFT_STATE];\n        latest(state).forEach(function (_value, key, _map) {\n          cb.call(thisArg, _this4.get(key), key, _this4);\n        });\n      }\n    }, {\n      key: \"get\",\n      value: function get(key) {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        var value = latest(state).get(key);\n        if (state.finalized_ || !isDraftable(value)) {\n          return value;\n        }\n        if (value !== state.base_.get(key)) {\n          return value;\n        }\n        var draft = createProxy(value, state);\n        prepareMapCopy(state);\n        state.copy_.set(key, draft);\n        return draft;\n      }\n    }, {\n      key: \"keys\",\n      value: function keys() {\n        return latest(this[DRAFT_STATE]).keys();\n      }\n    }, {\n      key: \"values\",\n      value: function values() {\n        var _this5 = this,\n          _ref8;\n        var iterator = this.keys();\n        return _ref8 = {}, _defineProperty(_ref8, Symbol.iterator, function () {\n          return _this5.values();\n        }), _defineProperty(_ref8, \"next\", function next() {\n          var r = iterator.next();\n          if (r.done) return r;\n          var value = _this5.get(r.value);\n          return {\n            done: false,\n            value: value\n          };\n        }), _ref8;\n      }\n    }, {\n      key: \"entries\",\n      value: function entries() {\n        var _this6 = this,\n          _ref9;\n        var iterator = this.keys();\n        return _ref9 = {}, _defineProperty(_ref9, Symbol.iterator, function () {\n          return _this6.entries();\n        }), _defineProperty(_ref9, \"next\", function next() {\n          var r = iterator.next();\n          if (r.done) return r;\n          var value = _this6.get(r.value);\n          return {\n            done: false,\n            value: [r.value, value]\n          };\n        }), _ref9;\n      }\n    }, {\n      key: _ref7,\n      value: function value() {\n        return this.entries();\n      }\n    }]);\n    return DraftMap;\n  }( /*#__PURE__*/_wrapNativeSuper(Map), (DRAFT_STATE, Symbol.iterator));\n  function proxyMap_(target, parent) {\n    return new DraftMap(target, parent);\n  }\n  function prepareMapCopy(state) {\n    if (!state.copy_) {\n      state.assigned_ = /* @__PURE__ */new Map();\n      state.copy_ = new Map(state.base_);\n    }\n  }\n  var DraftSet = /*#__PURE__*/function (_Set, _ref10) {\n    _inherits(DraftSet, _Set);\n    var _super2 = _createSuper(DraftSet);\n    function DraftSet(target, parent) {\n      var _this7;\n      _classCallCheck(this, DraftSet);\n      _this7 = _super2.call(this);\n      _this7[DRAFT_STATE] = {\n        type_: 3 /* Set */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        base_: target,\n        draft_: _assertThisInitialized(_this7),\n        drafts_: /* @__PURE__ */new Map(),\n        revoked_: false,\n        isManual_: false\n      };\n      return _this7;\n    }\n    _createClass(DraftSet, [{\n      key: \"size\",\n      get: function get() {\n        return latest(this[DRAFT_STATE]).size;\n      }\n    }, {\n      key: \"has\",\n      value: function has(value) {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        if (!state.copy_) {\n          return state.base_.has(value);\n        }\n        if (state.copy_.has(value)) return true;\n        if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n        return false;\n      }\n    }, {\n      key: \"add\",\n      value: function add(value) {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        if (!this.has(value)) {\n          prepareSetCopy(state);\n          markChanged(state);\n          state.copy_.add(value);\n        }\n        return this;\n      }\n    }, {\n      key: \"delete\",\n      value: function _delete(value) {\n        if (!this.has(value)) {\n          return false;\n        }\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        prepareSetCopy(state);\n        markChanged(state);\n        return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */\n        false);\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        if (latest(state).size) {\n          prepareSetCopy(state);\n          markChanged(state);\n          state.copy_.clear();\n        }\n      }\n    }, {\n      key: \"values\",\n      value: function values() {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        prepareSetCopy(state);\n        return state.copy_.values();\n      }\n    }, {\n      key: \"entries\",\n      value: function entries() {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        prepareSetCopy(state);\n        return state.copy_.entries();\n      }\n    }, {\n      key: \"keys\",\n      value: function keys() {\n        return this.values();\n      }\n    }, {\n      key: _ref10,\n      value: function value() {\n        return this.values();\n      }\n    }, {\n      key: \"forEach\",\n      value: function forEach(cb, thisArg) {\n        var iterator = this.values();\n        var result = iterator.next();\n        while (!result.done) {\n          cb.call(thisArg, result.value, result.value, this);\n          result = iterator.next();\n        }\n      }\n    }]);\n    return DraftSet;\n  }( /*#__PURE__*/_wrapNativeSuper(Set), (DRAFT_STATE, Symbol.iterator));\n  function proxySet_(target, parent) {\n    return new DraftSet(target, parent);\n  }\n  function prepareSetCopy(state) {\n    if (!state.copy_) {\n      state.copy_ = /* @__PURE__ */new Set();\n      state.base_.forEach(function (value) {\n        if (isDraftable(value)) {\n          var draft = createProxy(value, state);\n          state.drafts_.set(value, draft);\n          state.copy_.add(draft);\n        } else {\n          state.copy_.add(value);\n        }\n      });\n    }\n  }\n  function assertUnrevoked(state) {\n    if (state.revoked_) die(3, JSON.stringify(latest(state)));\n  }\n  loadPlugin(\"MapSet\", {\n    proxyMap_: proxyMap_,\n    proxySet_: proxySet_\n  });\n}\n\n// src/immer.ts\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);\nvar applyPatches = immer.applyPatches.bind(immer);\nvar createDraft = immer.createDraft.bind(immer);\nvar finishDraft = immer.finishDraft.bind(immer);\nfunction castDraft(value) {\n  return value;\n}\nfunction castImmutable(value) {\n  return value;\n}\nexport { Immer2 as Immer, applyPatches, castDraft, castImmutable, createDraft, current, enableMapSet, enablePatches, finishDraft, freeze, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseStrictShallowCopy };","map":{"version":3,"mappings":"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","names":["NOTHING","Symbol","for","DRAFTABLE","DRAFT_STATE","errors","process","env","NODE_ENV","plugin","thing","data","die","error","e","args","msg","apply","Error","getPrototypeOf","Object","isDraft","value","isDraftable","isPlainObject","Array","isArray","constructor","_value$constructor","isMap","isSet","objectCtorString","prototype","toString","proto","Ctor","hasOwnProperty","call","Function","original","base_","each","obj","iter","getArchtype","entries","forEach","key","entry","index","state","type_","has","prop","get","set","propOrOldValue","t","add","is","x","y","target","Map","Set","latest","copy_","shallowCopy","base","strict","slice","create","assign","descriptors","getOwnPropertyDescriptors","keys","Reflect","ownKeys","i","length","desc","writable","configurable","enumerable","freeze","deep","isFrozen","clear","delete","dontMutateFrozenCollections","_key","plugins","getPlugin","pluginKey","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","path","childValue","finalizeProperty","scope_","finalized_","resultEach","generatePatches_","parentState","targetObject","rootPath","targetIsSet","assigned_","concat","res","autoFreeze_","createProxyProxy","parent","draft_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","source","readPropFromProto","peek","prepareCopy","createProxy","getDescriptorFromProto","current","currentState","markChanged","Number","isNaN","deleteProperty","getOwnPropertyDescriptor","owner","defineProperty","setPrototypeOf","fn","arguments","parseInt","_desc$get","useStrictShallowCopy_","Immer","config","_classCallCheck","recipe","defaultBase","self","_this","curriedProduce","produce","_this2","hasError","p","ip","produceWithPatches","patches","inversePatches","autoFreeze","setAutoFreeze","useStrictShallowCopy","setUseStrictShallowCopy","_createClass","patch","op","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","push","currentImpl","copy","enablePatches","errorOffset","REPLACE","ADD","REMOVE","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","clonePatchValueIfNeeded","assignedValue","origValue","unshift","baseValue","replacement","parentType","join","type","deepClonePatchValue","splice","map","from","k","v","cloned","enableMapSet","DraftMap","_inherits","_this3","size","assertUnrevoked","prepareMapCopy","cb","thisArg","_value","_map","_this4","_ref8","iterator","_this5","values","r","next","done","_ref9","_this6","DraftSet","_this7","prepareSetCopy","JSON","stringify","bind","applyPatches","createDraft","finishDraft","castDraft","castImmutable"],"sources":["E:\\GoIT\\Zad dom\\goit-react-hw-08-phonebook\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\utils\\env.ts","E:\\GoIT\\Zad dom\\goit-react-hw-08-phonebook\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\utils\\errors.ts","E:\\GoIT\\Zad dom\\goit-react-hw-08-phonebook\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\utils\\common.ts","E:\\GoIT\\Zad dom\\goit-react-hw-08-phonebook\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\utils\\plugins.ts","E:\\GoIT\\Zad dom\\goit-react-hw-08-phonebook\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\scope.ts","E:\\GoIT\\Zad dom\\goit-react-hw-08-phonebook\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\finalize.ts","E:\\GoIT\\Zad dom\\goit-react-hw-08-phonebook\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\proxy.ts","E:\\GoIT\\Zad dom\\goit-react-hw-08-phonebook\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\immerClass.ts","E:\\GoIT\\Zad dom\\goit-react-hw-08-phonebook\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\current.ts","E:\\GoIT\\Zad dom\\goit-react-hw-08-phonebook\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\plugins\\patches.ts","E:\\GoIT\\Zad dom\\goit-react-hw-08-phonebook\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\plugins\\mapset.ts","E:\\GoIT\\Zad dom\\goit-react-hw-08-phonebook\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\immer.ts"],"sourcesContent":["// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","export const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = typeof e === \"function\" ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie\n} from \"../internal\"\n\nexport const getPrototypeOf = Object.getPrototypeOf\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\tObject.entries(obj).forEach(([key, value]) => {\n\t\t\titer(key, value, obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: Array.isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchType.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (t === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: boolean) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\n\tif (!strict && isPlainObject(base)) {\n\t\tif (!getPrototypeOf(base)) {\n\t\t\tconst obj = Object.create(null)\n\t\t\treturn Object.assign(obj, base)\n\t\t}\n\t\treturn {...base}\n\t}\n\n\tconst descriptors = Object.getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = Reflect.ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (_key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result = state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\t// And we let finalizeProperty know it needs to re-add non-draft children back to the target\n\t\tlet resultEach = result\n\t\tlet isSet = false\n\t\tif (state.type_ === ArchType.Set) {\n\t\t\tresultEach = new Set(result)\n\t\t\tresult.clear()\n\t\t\tisSet = true\n\t\t}\n\t\teach(resultEach, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path, isSet)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath,\n\ttargetIsSet?: boolean\n) {\n\tif (process.env.NODE_ENV !== \"production\" && childValue === targetObject)\n\t\tdie(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ArchType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t} else if (targetIsSet) {\n\t\ttargetObject.add(childValue)\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\tImmerScope\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(value, state))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {\n\tbase_: any\n\tcopy_: any\n\tscope_: ImmerScope\n}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: boolean = false\n\n\tconstructor(config?: {autoFreeze?: boolean; useStrictShallowCopy?: boolean}) {\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\tif (typeof config?.useStrictShallowCopy === \"boolean\")\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: boolean) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(copy, (key, childValue) => {\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tProxyArrayState,\n\tMapState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tgetPrototypeOf,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tArchType,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING,\n\terrors\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst errorOffset = 16\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\terrors.push(\n\t\t\t'Sets cannot have \"replace\" patches.',\n\t\t\tfunction(op: string) {\n\t\t\t\treturn \"Unsupported patch operation: \" + op\n\t\t\t},\n\t\t\tfunction(path: string) {\n\t\t\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t\t\t},\n\t\t\t\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t\t)\n\t}\n\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ArchType.Object:\n\t\t\tcase ArchType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ArchType.Array:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ArchType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tfor (let i = copy_.length - 1; base_.length <= i; --i) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tinversePatches.push({\n\t\t\t\top: REMOVE,\n\t\t\t\tpath\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tlet p = path[i]\n\t\t\t\tif (typeof p !== \"string\" && typeof p !== \"number\") {\n\t\t\t\t\tp = \"\" + p\n\t\t\t\t}\n\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === ArchType.Object || parentType === ArchType.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\")\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(errorOffset + 2, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\tdie(errorOffset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(errorOffset + 1, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tdie,\n\tArchType,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\tclass DraftMap extends Map {\n\t\t[DRAFT_STATE]: MapState\n\n\t\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tset(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tforEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tget(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.entries()\n\t\t}\n\t}\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tclass DraftSet extends Set {\n\t\t[DRAFT_STATE]: SetState\n\t\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tadd(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tforEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\t}\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\n"]},"metadata":{},"sourceType":"module"}